# relay-note43

## 퀘스트 4개

### 🎯 1. 피어 피드백 시, 아이스브레이킹 주제 추천 받아 활용

🧠 **배경 및 목적:**

**배경:**

• (lucy님의 이야기) + 쉽게 말할 수 있는 피드백이 되길 바람.<br>
• 문제 해결 집중 및 만난지 얼마 되지 않음 <br>
⇒ 아이스브레이킹 할 시간이 없었음 그래서 딱딱한 이야기만 하여 아쉬움

**목적**

• 이런 것들을 해소해보자 라는 마음으로 생각하게 되었음.

<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

AI가 추천해준 주제를 가지고 **아이스브레이킹 성공!**

<br>

**예시:** <br>
“내가 처음 짠 코드 이야기”

“VS Code 테마는 다크 모드 vs 라이트 모드?”

“아침형 인간 vs 야행성?”

"내가 개발 외에 가장 몰두하는 취미는?"

“나에게 '최애' 개발 도구 (IDE, 확장 프로그램, 유틸리티 등) 한 가지만 꼽는다면? 그 이유는요?”

⇒  AI의 답변 중 하나를 피어세션에서 물어보며 아이스 브레이킹하기
<br>
<br>

### 🎯 2. 내가 가진 지식을 기반으로 (학습 목표를 달성하기 위해) 어느 정도 학습하면 될지 질문

🧠 **배경 및 목적:**

**배경:**

• 학습과 구현의 비중을 어떻게 잡아야 하는가? <br>
• 피어 피드백 시간 외에 혼자 미션을 수행하는데 이 방향이 맞나? (혼자서 해쳐나가는 느낌이라서 힘들었음) <br>

**목적:**

• 이런 것들을 해소해보자 라는 마음으로 생각하게 되었음.

<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

AI가 추천해준 주제를 가지고 **아이스브레이킹 성공!**

<br>

<details>
<summary>예시</summary>

**1. 반드시 익혀야 할 CS 지식 & 학습 깊이**

**가상 메모리 & 프로세스 레이아웃**

- 페이징 vs 세그멘테이션: 가상→물리 주소 변환- Text/Data(GVAR)/Heap/Stack 배치·성장 방향
- 주소 변환 과정을 다이어그램으로 그려 설명할 수 있을 것- 각 영역이 언제·어떻게 커지는지 예시로 말할 수 있을 것

**어셈블리 호출·스택 컨벤션**

- CALL/RET 시 PC·SP 조작- PUSH/POP, LOAD/STORE 명령으로 스택에 값 쌓고 빼기
- 간단한 ASM 예제(5줄) 보고 스택 변화를 손으로 추적해 볼 것- 함수 호출 시 스택 프레임 생성·소멸 과정을 설명할 수 있을 것

**포인터 연산 & 메모리 할당**

- 포인터 산술(증가·감소 → 바이트 이동)- First-fit 동적할당 알고리즘 기초
- p+1이 바이트로 얼마만큼 이동하는지 계산해 볼 것- free list 기반 first-fit 의사코드를 5줄 이내로 작성해 볼 것

**가비지 컬렉션 기초**

- 참조 카운팅 vs 마크-앤-스윕 원리 및 흐름
- 두 방식의 장단점을 표로 요약해 보고- 마크-앤-스윕 의사코드를 10~15줄 수준으로 스케치해 볼 것

**시스템 모니터링 도구 활용**

- ps, pmap, vmstat, free, Node.js process.memoryUsage() 등 실행 중 프로세스 메모리 정보 확인 방법
- 각 명령어가 보여 주는 RSS·VSZ·Swap·cache 등을 해석할 수 있을 것- Node.js API 결과를 직접 출력해 읽어볼 것

- 0–75분: 예시 시나리오 통합 실행 + 로그 캡처- 75–150분: README.md에 실행 예시 코드 블록·출력 결과·흐름 차트 추가

**설계 문서화 & 다이어그램**

- README.md 작성: 클래스·메서드 사양 정리- 손 그림 수준의 데이터 흐름·호출 흐름도
- 주요 API 목록과 파라미터·리턴을 표로 정리할 것- 플로우 차트를 간단히 그려 “CALL → 스택 푸시 → PC 이동” 등을 설명할 것

<br>

**2. 16시간 완성 플랜**

**1.0h**

가상 메모리 & 레이아웃 스캔

- 0–10분: 페이징 vs 세그멘테이션 3문장 요약- 10–25분: Text/Data/Heap/Stack 다이어그램 작성- 25–45분: 페이지 테이블 구조 손그림- 45–60분: 페이지 폴트·교체 알고리즘 개념 스캔

**1.5h**

어셈블리 호출·스택 실습

- 0–15분: CALL/RET 동작 1줄 요약- 15–35분: push ebp/mov ebp,esp 패턴 해석- 35–65분: [ebp-4] 주소 계산 연습- 65–90분: 함수 호출 시 SP·PC 변화 그림

**1.5h**

포인터 연산 & 동적 할당 원리

- 0–20분: p+1 바이트 계산 연습- 20–40분: first-fit 의사코드 5줄 스케치- 40–75분: 조각화 예시 그림 정리- 75–90분: uint8_t heap[256] 간단 할당기 구현

**0.75h**

가비지 컬렉션 기초

- 0–15분: 참조 카운팅 vs 마크-앤-스윕 비교 표 작성- 15–35분: 마크-앤-스윕 의사코드 10~15줄 스케치- 35–45분: 가상 포인터 그래프 예제 마크/스윕 시뮬레이션

**0.75h**

시스템 모니터링 도구 활용

- 0–15분: ps aux → RSS·VSZ 해석- 15–30분: vmstat·free → Swap·cache 용어 정리- 30–45분: Node.js process.memoryUsage() 출력 실습

**1.5h**

설계 문서화 & AI 템플릿 생성

- 0–30분: README.md 틀 작성(목적·목표·API 목록)- 30–60분: 메서드 시그니처 표 정리- 60–90분: AI에 클래스 스켈레톤 요청 후 초기 파일 생성

**2.5h**

핵심 기능 구현 I

- 0–30분: setSize 구현 (유효값 체크·맵 저장)- 30–120분: locate + usage + reset 구현 및 즉시 검증- 120–150분: 로그로 결과 확인

**2.5h**

핵심 기능 구현 II

- 0–60분: alloc 구현 (크기 계산·8바이트 패딩·스택 푸시)- 60–150분: free + next(CALL/RETURN) 구현 및 검증- 150–180분: callstack 구현

**1.5h**

부가기능 & 안정화

- 0–40분: heapdump 구현 (타입·주소·길이·참조 정보 문자열화)- 40–80분: garbageCollect 구현 (미참조 블록 해제)- 80–90분: reset 예외 보강 및 초기화

**2.5h**

종합 테스트 & 문서 보강

- 0–75분: 예시 시나리오 통합 실행 + 로그 캡처- 75–150분: README.md에 실행 예시 코드 블록·출력 결과·흐름 차트 추가
</details>

<br>

### 🎯 3. 학습 내용을 기반으로 AI 만화 생성

🧠 **배경 및 목적:**

**배경:**

• 요즘 AI로 만화를 생성하는 일 많음 <br>
• 기술 개념이나 추상적인 원리를 글로만 읽다 보면,
**머릿속에 생생하게 그려지지 않아 이해가 어려운 경우가 많음. → 배운 내용을 기반으로 한 만화나 스토리 형태의 시각자료**는 내용을 기억하고 연결하는 데 큰 도움이 됨
<br>

**목적**

• 배운 내용에 대해서 지속성 증가 <br>
• 다른 사람이 AI를 볼 시에 이해하기 쉽도록 할 수 있음. (공유) <br>
• 만화가 내가 원하는 내용이 아닐 시 다른 그려야함 ⇒ 프롬프트를 어떻게 쓰면 더 잘 나오는지 알 수 있게 된다. <br>
<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

• AI가 생성한 만화가 **학습한 내용과 맞는지 확인** <br>
• 맞지 않다면, 다시 만화 생성 시도! (즉, 원하는 만화가 나올 때까지 돌려본다.) <br>
• 그 후, **학습 정리 파일에 이미지로 부착** <br>
<br>

<details>
<summary>예시</summary>

<img src="https://github.com/boostcampwm2025/relay-note43/blob/main/image.png?raw=true" width="500">

<img src="https://github.com/boostcampwm2025/relay-note43/blob/main/page.png?raw=true" width="500">

• 가상 메모리의 페이징 기법에 관해서 만든 만화들 이다.

</details>

<br>

### 🎯 4. 학습 내용을 기반으로 면접 질문 생성

🧠 **배경 및 목적:**

**배경:**

• 요즘 면접에서 CS 질문 많이 나옴 <br>
• CS 공부와 면접 공부를 따로 하는 것보다 한 번에 같이 하는 것이 어떨까 생각함.
<br>

**목적**

• 면접에서의 CS 질문 대비 <br>
• 내가 배운 지식을 내 언어로 정리해서 표현하는 과정 필요. 이런 과정을 좀 더 익숙하게 하기 위함 <br>
<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

• 면접에 대한 답변 작성 후, 이를 기반으로 AI에게 예상 꼬리 질문 요청 <br>

<details>
<summary>예시</summary>
✅ **1. 질문**

**iOS에서 메모리 사용 현황을 분석하고 누수를 확인하기 위한 주요 도구는 무엇인가요?**

**답변**: iOS에서는 메모리 분석을 위해 Instruments의 다양한 도구를 사용합니다.

- **Allocations**는 힙에 할당된 객체의 크기, 생명주기, 타입 등을 추적할 수 있고,
- **Leaks**는 자동으로 누수된 객체를 탐지합니다.
- **Memory Graph Debugger**는 객체 간 참조 관계를 시각적으로 분석할 수 있습니다.또한, **Malloc Stack Logging**을 활성화하면 객체가 할당된 호출 스택까지 추적할 수 있어 누수 분석에 유리합니다.

**예상 꼬리질문**

- Instruments에서 'Zombie Object'는 어떤 의미인가요?
- Malloc Stack Logging은 어떻게 활성화하나요? 실전에서 사용 시 주의점은?

✅ **2. 질문**

**가상 메모리 분석에서 Stack, Heap, Text 영역은 어떻게 구분되고 각각 어떻게 분석하나요?**

**답변:**

- **Stack 영역**은 함수 호출 시 지역 변수나 리턴 주소 등을 저장하는 곳으로, pmap, vmmap, /proc/[PID]/maps 등의 명령어를 통해 분석할 수 있습니다.
- **Heap 영역**은 런타임 시 동적으로 할당되는 메모리로, iOS에서는 Instruments의 Allocations, Leaks 도구로 분석하며, heaptrack이나 valgrind 등도 활용됩니다.
- **Text 영역**은 코드 실행 부분으로, nm, objdump, vmmap 등을 통해 확인할 수 있습니다.이 외에도 공유 메모리나 스왑 영역, Dirty/Clean 페이지 등은 smem, vm_stat 등의 도구로 구체적인 분석이 가능합니다.

**예상 꼬리질문**

- Stack Overflow와 Heap Overflow의 차이는 무엇인가요?
- 왜 Heap은 Fragmentation 문제가 발생하고 Stack은 그렇지 않은가요?

✅ **3. 질문**

**iOS에서 ARC 환경에서도 메모리 누수가 발생할 수 있다면, 그 예와 원인은 무엇인가요?**

**답변**: ARC는 객체의 참조 횟수를 자동으로 관리하지만, “순환 참조(retain cycle)”가 발생하면 메모리 누수가 발생할 수 있습니다. 예를 들어, ViewController가 closure를 캡처하고 그 closure가 다시 ViewController를 참조할 때

서로의 참조가 끊기지 않아 메모리에서 해제되지 않는 문제가 생깁니다. 이를 해결하기 위해 [weak self]나 [unowned self]를 사용해 순환 참조를 방지해야 합니다.

**예상 꼬리질문**

- weak와 unowned의 차이는 무엇인가요?
- ARC 기반 메모리 관리는 GC(Garbage Collection)과 어떤 차이가 있나요?
</details>
