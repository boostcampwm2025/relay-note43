# 릴레이 노트 43

## 👥 토론 내용

### 🔻 AI를 통해서 해결하고 싶은 게 있는가?

1. **AI 학습 로드 맵 생성**
2. **챌린지 힘든 상황 위로**
3. **정보 찾기(구글링 대신에)**

→ 하지만, CS 지식 학습에 대해서 구글링하거나 하는 것이 정확하게 나오지 않을까?라는 생각을 함.

4. **오늘의 배운 것이 왜 중요한지 정리하기**
5. **AI 심리 테스트**
6. **AI 밸런스 게임**
7. **AI와 릴레이 소설 쓰기**

### 💭 생각의 방향을 잡고 아이디어 회의

• 이번주에 학습하면서 어려웠던 점, 고민 그런 것들을 해결할 수 있는 방향으로 잡아도 될 것 같음.

**'배운 학습을 이해하기'에 관련된 퀘스트 토론**

🔹 오늘 배운 CS 내용을 복습용 자료로 활용하기 위해 플래시 카드를 만들어달라고 하는 건 어떨까?  
🔹 학습 정리한 것을 토대로 간단한 퀴즈를 출제해달라고 하는 거 어떨까?  
🔹 학습 내용을 기반으로 AI 만화를 만드는 것은 어떨까? (✅)  
🔹 학습한 내용을 기반으로 면접 질문을 만드는 것은 어떨까? (✅)  
🔹 친구나 후배에게 설명해줄 것처럼 AI에게 요청해서 쉽게 정리하는 것은 어떨까?  
🔹 오늘 해결한 문제와 CS를 기반으로 배운 지식을 오디오북 형식 스크립트 형식으로 작성해달라는 것은 어떨까?  
🔹오늘 푼 문제 유형을 제공하고 CS 관련 플레이리스트를 만드는 것은 어떨까?

**그 외의 퀘스트 토론**

🔹 어색함을 해소하기 위해서 아이스브레이킹을 하면 어떨까?  
🔹 gist에 올리는 파일을 작성하는 것에 시간이 많이 소요되는 거 같다. 이에 내가 작성한 내용을 기반으로 파일을 작성해달라고 하면 어떨까?  
🔹 피어 피드백 시 작성한 코드를 어떻게 설명하면 좋을지 설명해달라고 하는 것은 어떨까?  
🔹 미션을 수행하다보니 잠을 잘 자지 못한다. 이에 시간표를 짜달라는 것은 어떨까?  
🔹 학습과 구현의 비중을 어떻게 잡아야 하는지 이에 대해 어느 정도 학습하면 될지 물어보는 건 어떨까? (✅)  
🔹 어색함을 해소하기 위해서 아이스브레이킹을 하면 어떨까? (✅)

---

## ✅ 퀘스트 4개

### 🎯 1. 피어 피드백 시, 아이스브레이킹 주제 추천 받아 활용

🧠 **배경 및 목적:**

**배경:**

• (lucy님의 이야기) + 쉽게 말할 수 있는 피드백이 되길 바람.<br>
• 문제 해결 집중 및 만난지 얼마 되지 않음 <br>
⇒ 아이스브레이킹 할 시간이 없었음 그래서 딱딱한 이야기만 하여 아쉬움

**목적**

• 이런 것들을 해소해보자 라는 마음으로 생각하게 되었음.

<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

AI가 추천해준 주제를 가지고 **아이스브레이킹 성공!**

<br>

**예시:** <br>
“내가 처음 짠 코드 이야기”

“VS Code 테마는 다크 모드 vs 라이트 모드?”

“아침형 인간 vs 야행성?”

"내가 개발 외에 가장 몰두하는 취미는?"

“나에게 '최애' 개발 도구 (IDE, 확장 프로그램, 유틸리티 등) 한 가지만 꼽는다면? 그 이유는요?”

⇒  AI의 답변 중 하나를 피어세션에서 물어보며 아이스 브레이킹하기
<br>
<br>

### 🎯 2. 내가 가진 지식을 기반으로 (학습 목표를 달성하기 위해) 어느 정도 학습하면 될지 질문

🧠 **배경 및 목적:**

**배경:**

• 학습과 구현의 비중을 어떻게 잡아야 하는가? <br>
• 피어 피드백 시간 외에 혼자 미션을 수행하는데 이 방향이 맞나? (혼자서 해쳐나가는 느낌이라서 힘들었음) <br>

**목적:**

• 이런 것들을 해소해보자 라는 마음으로 생각하게 되었음.

<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

AI가 추천해준 주제를 가지고 **아이스브레이킹 성공!**

<br>

<details>
<summary>예시</summary>

**1. 반드시 익혀야 할 CS 지식 & 학습 깊이**

**가상 메모리 & 프로세스 레이아웃**

- 페이징 vs 세그멘테이션: 가상→물리 주소 변환- Text/Data(GVAR)/Heap/Stack 배치·성장 방향
- 주소 변환 과정을 다이어그램으로 그려 설명할 수 있을 것- 각 영역이 언제·어떻게 커지는지 예시로 말할 수 있을 것

**어셈블리 호출·스택 컨벤션**

- CALL/RET 시 PC·SP 조작- PUSH/POP, LOAD/STORE 명령으로 스택에 값 쌓고 빼기
- 간단한 ASM 예제(5줄) 보고 스택 변화를 손으로 추적해 볼 것- 함수 호출 시 스택 프레임 생성·소멸 과정을 설명할 수 있을 것

**포인터 연산 & 메모리 할당**

- 포인터 산술(증가·감소 → 바이트 이동)- First-fit 동적할당 알고리즘 기초
- p+1이 바이트로 얼마만큼 이동하는지 계산해 볼 것- free list 기반 first-fit 의사코드를 5줄 이내로 작성해 볼 것

**가비지 컬렉션 기초**

- 참조 카운팅 vs 마크-앤-스윕 원리 및 흐름
- 두 방식의 장단점을 표로 요약해 보고- 마크-앤-스윕 의사코드를 10~15줄 수준으로 스케치해 볼 것

**시스템 모니터링 도구 활용**

- ps, pmap, vmstat, free, Node.js process.memoryUsage() 등 실행 중 프로세스 메모리 정보 확인 방법
- 각 명령어가 보여 주는 RSS·VSZ·Swap·cache 등을 해석할 수 있을 것- Node.js API 결과를 직접 출력해 읽어볼 것

- 0–75분: 예시 시나리오 통합 실행 + 로그 캡처- 75–150분: README.md에 실행 예시 코드 블록·출력 결과·흐름 차트 추가

**설계 문서화 & 다이어그램**

- README.md 작성: 클래스·메서드 사양 정리- 손 그림 수준의 데이터 흐름·호출 흐름도
- 주요 API 목록과 파라미터·리턴을 표로 정리할 것- 플로우 차트를 간단히 그려 “CALL → 스택 푸시 → PC 이동” 등을 설명할 것

<br>

**2. 16시간 완성 플랜**

**1.0h**

가상 메모리 & 레이아웃 스캔

- 0–10분: 페이징 vs 세그멘테이션 3문장 요약- 10–25분: Text/Data/Heap/Stack 다이어그램 작성- 25–45분: 페이지 테이블 구조 손그림- 45–60분: 페이지 폴트·교체 알고리즘 개념 스캔

**1.5h**

어셈블리 호출·스택 실습

- 0–15분: CALL/RET 동작 1줄 요약- 15–35분: push ebp/mov ebp,esp 패턴 해석- 35–65분: [ebp-4] 주소 계산 연습- 65–90분: 함수 호출 시 SP·PC 변화 그림

**1.5h**

포인터 연산 & 동적 할당 원리

- 0–20분: p+1 바이트 계산 연습- 20–40분: first-fit 의사코드 5줄 스케치- 40–75분: 조각화 예시 그림 정리- 75–90분: uint8_t heap[256] 간단 할당기 구현

**0.75h**

가비지 컬렉션 기초

- 0–15분: 참조 카운팅 vs 마크-앤-스윕 비교 표 작성- 15–35분: 마크-앤-스윕 의사코드 10~15줄 스케치- 35–45분: 가상 포인터 그래프 예제 마크/스윕 시뮬레이션

**0.75h**

시스템 모니터링 도구 활용

- 0–15분: ps aux → RSS·VSZ 해석- 15–30분: vmstat·free → Swap·cache 용어 정리- 30–45분: Node.js process.memoryUsage() 출력 실습

**1.5h**

설계 문서화 & AI 템플릿 생성

- 0–30분: README.md 틀 작성(목적·목표·API 목록)- 30–60분: 메서드 시그니처 표 정리- 60–90분: AI에 클래스 스켈레톤 요청 후 초기 파일 생성

**2.5h**

핵심 기능 구현 I

- 0–30분: setSize 구현 (유효값 체크·맵 저장)- 30–120분: locate + usage + reset 구현 및 즉시 검증- 120–150분: 로그로 결과 확인

**2.5h**

핵심 기능 구현 II

- 0–60분: alloc 구현 (크기 계산·8바이트 패딩·스택 푸시)- 60–150분: free + next(CALL/RETURN) 구현 및 검증- 150–180분: callstack 구현

**1.5h**

부가기능 & 안정화

- 0–40분: heapdump 구현 (타입·주소·길이·참조 정보 문자열화)- 40–80분: garbageCollect 구현 (미참조 블록 해제)- 80–90분: reset 예외 보강 및 초기화

**2.5h**

종합 테스트 & 문서 보강

- 0–75분: 예시 시나리오 통합 실행 + 로그 캡처- 75–150분: README.md에 실행 예시 코드 블록·출력 결과·흐름 차트 추가
</details>

<br>

### 🎯 3. 학습 내용을 기반으로 AI 만화 생성

🧠 **배경 및 목적:**

**배경:**

• 요즘 AI로 만화를 생성하는 일 많음 <br>
• 기술 개념이나 추상적인 원리를 글로만 읽다 보면,
**머릿속에 생생하게 그려지지 않아 이해가 어려운 경우가 많음. → 배운 내용을 기반으로 한 만화나 스토리 형태의 시각자료**는 내용을 기억하고 연결하는 데 큰 도움이 됨
<br>

**목적**

• 배운 내용에 대해서 지속성 증가 <br>
• 다른 사람이 AI를 볼 시에 이해하기 쉽도록 할 수 있음. (공유) <br>
• 만화가 내가 원하는 내용이 아닐 시 다른 그려야함 ⇒ 프롬프트를 어떻게 쓰면 더 잘 나오는지 알 수 있게 된다. <br>
<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

• AI가 생성한 만화가 **학습한 내용과 맞는지 확인** <br>
• 맞지 않다면, 다시 만화 생성 시도! (즉, 원하는 만화가 나올 때까지 돌려본다.) <br>
• 그 후, **학습 정리 파일에 이미지로 부착** <br>
<br>

<details>
<summary>예시</summary>

<img src="https://github.com/boostcampwm2025/relay-note43/blob/main/image.png?raw=true" width="500">

<img src="https://github.com/boostcampwm2025/relay-note43/blob/main/page.png?raw=true" width="500">

• 가상 메모리의 페이징 기법에 관해서 만든 만화들 이다.

</details>

<br>

### 🎯 4. 학습 내용을 기반으로 면접 질문 생성

🧠 **배경 및 목적:**

**배경:**

• 요즘 면접에서 CS 질문 많이 나옴 <br>
• CS 공부와 면접 공부를 따로 하는 것보다 한 번에 같이 하는 것이 어떨까 생각함.
<br>

**목적**

• 면접에서의 CS 질문 대비 <br>
• 내가 배운 지식을 내 언어로 정리해서 표현하는 과정 필요. 이런 과정을 좀 더 익숙하게 하기 위함 <br>
<br>

⚖️ **달성 기준(수행 여부를 판단할 수 있는 기준):**

• 면접에 대한 답변 작성 후, 이를 기반으로 AI에게 예상 꼬리 질문 요청 <br>

<details>
<summary>예시</summary>

✅ **1. 질문**

**iOS에서 메모리 사용 현황을 분석하고 누수를 확인하기 위한 주요 도구는 무엇인가요?**

**답변**: iOS에서는 메모리 분석을 위해 Instruments의 다양한 도구를 사용합니다.

- **Allocations**는 힙에 할당된 객체의 크기, 생명주기, 타입 등을 추적할 수 있고,
- **Leaks**는 자동으로 누수된 객체를 탐지합니다.
- **Memory Graph Debugger**는 객체 간 참조 관계를 시각적으로 분석할 수 있습니다.또한, **Malloc Stack Logging**을 활성화하면 객체가 할당된 호출 스택까지 추적할 수 있어 누수 분석에 유리합니다.

**예상 꼬리질문**

- Instruments에서 'Zombie Object'는 어떤 의미인가요?
- Malloc Stack Logging은 어떻게 활성화하나요? 실전에서 사용 시 주의점은?

✅ **2. 질문**

**가상 메모리 분석에서 Stack, Heap, Text 영역은 어떻게 구분되고 각각 어떻게 분석하나요?**

**답변:**

- **Stack 영역**은 함수 호출 시 지역 변수나 리턴 주소 등을 저장하는 곳으로, pmap, vmmap, /proc/[PID]/maps 등의 명령어를 통해 분석할 수 있습니다.
- **Heap 영역**은 런타임 시 동적으로 할당되는 메모리로, iOS에서는 Instruments의 Allocations, Leaks 도구로 분석하며, heaptrack이나 valgrind 등도 활용됩니다.
- **Text 영역**은 코드 실행 부분으로, nm, objdump, vmmap 등을 통해 확인할 수 있습니다.이 외에도 공유 메모리나 스왑 영역, Dirty/Clean 페이지 등은 smem, vm_stat 등의 도구로 구체적인 분석이 가능합니다.

**예상 꼬리질문**

- Stack Overflow와 Heap Overflow의 차이는 무엇인가요?
- 왜 Heap은 Fragmentation 문제가 발생하고 Stack은 그렇지 않은가요?

✅ **3. 질문**

**iOS에서 ARC 환경에서도 메모리 누수가 발생할 수 있다면, 그 예와 원인은 무엇인가요?**

**답변**: ARC는 객체의 참조 횟수를 자동으로 관리하지만, “순환 참조(retain cycle)”가 발생하면 메모리 누수가 발생할 수 있습니다. 예를 들어, ViewController가 closure를 캡처하고 그 closure가 다시 ViewController를 참조할 때

서로의 참조가 끊기지 않아 메모리에서 해제되지 않는 문제가 생깁니다. 이를 해결하기 위해 [weak self]나 [unowned self]를 사용해 순환 참조를 방지해야 합니다.

**예상 꼬리질문**

- weak와 unowned의 차이는 무엇인가요?
- ARC 기반 메모리 관리는 GC(Garbage Collection)과 어떤 차이가 있나요?
</details>

---

- S006\_김예슬 - 피어 피드백 시, 아이스브레이킹 주제 추천 받아 활용

  - 선택한 이유: 미션을 하고 늦은 시간에 잠이 들어 모두들 아침에 피곤하실 것 같은데, 가벼운 주제로 아이스브레이킹을 하고 피어 피드백을 시작하면 좋은 분위기에서 피드백을 진행할 수 있을 것 같습니다. 다음주엔 새로운 팀원분들을 만나기도 하고요! 🤗

- J053\_김영서 - 내가 가진 지식을 기반으로 (학습 목표를 달성하기 위해) 어느 정도 학습하면 될지 질문

  - 선택한 이유: 챌린지를 시작하면 구현을 시작하기 전 우선 사전 지식을 알고있어야 한다. 주어진 정보로 학습을 하고, 설계를 하고, 구현을 하는 과정에서 중간중간 필요한 지식을 습득하는것이 필요에 의한 학습이기 때문에 더욱 머리속에 길게 남을 것 같지만, 이는 시간이 오래 걸리는 작업이기 때문에 하루동안 결과를 내야 하는 챌린지 과정에서는 수행하기 어려울 수 있다는 생각이 들었다. 따라서 AI에게 문제를 주고 문제를 수행하기 위해 필요한 개념이 무엇인지 알려주고, 그 개념을 우선 학습한 뒤에 구현부에서 '아 이래서 이 개념을 알고 있어야 하는구나'라는걸 느끼며 학습해도 괜찮은 방법일것 같아서 선택하였다.

- J193\_이수진 - 피어 피드백 시, 아이스브레이킹 주제 추천 받아 활용

  - 선택한 이유: 처음 만난 동료들과 피드백을 주고받을 때 어색하게 딱딱하게 시작되는 경우가 있었습니다. 그래서 AI가 추천해주는 질문으로 자연스럽게 대화를 시작하면 서로를 더 잘 이해하고 피드백도 편하게 주고받을 수 있을 거라고 생각해 이 퀘스트를 선택했습니다.

- J231\_임승찬 - 내가 가진 지식을 기반으로 (학습 목표를 달성하기 위해) 어느 정도 학습하면 될지 질문
  - 선택한 이유: 한 주 동안 챌린지 미션을 진행하면서 고민해 왔던 내용이 학습과 구현의 비중을 어떻게 두어야 할까? 라는 고민이 있었습니다. 또는 어떤 주제를 가지고 학습을 시작해야 할까? 라는 고민이 있었는데 2번과 같은 퀘스트가 저에게 해답을 줄 수 있는 퀘스트일 것 같고 챌린지 기간 동안 더욱 성장할 수 있을 것 같아 선택하였습니다.

## 1주차 퀘스트 결과

<details>
  <summary>J231_임승찬</summary>

###  진행 방식

> 오늘 미션의 학습과 구현의 비중을 어떻게 잡아야 할까?
> 

### 결과

```
📅 하루 루틴 추천 (6~10시간 기준)
시간대	활동 유형	설명
⏰ 오전 (2~3h)	핵심 개념 학습	미션의 이론, 배경, 예제 코드 학습 (읽기 + 정리)
🔁 오전 후반오후 (45h)	구현 중심 실습	직접 코딩, 실습, 디버깅, 테스트
🧠 저녁 전후 (1~2h)	복습 + 회고	구현 중 헷갈렸던 부분, 공식 문서, 토론 정리
🗣️ 팀/스터디 (1h 내외)	지식 공유/피드백	서로 구현 비교, 질문/답변, 코드리뷰 등

✨ 50:50 비중이 이상적 → 학습 4050%, 구현 5060%

🎯 미션별 전략
미션 유형	추천 전략
🔎 개념 중심 (ex: 패턴, 구조, 비동기 등)	오전에 학습 집중, 구현은 최소 실습
⚙️ 구현 중심 (ex: 스레드, 이벤트 시스템 등)	빠르게 개념 확인 후, 바로 구현 / 테스트 반복
🧩 토론/정리 중심	학습 → 정리 → 구현 예시 → 발표 준비 순서로 진행
```

### 느낀점

미션을 진행하느라 릴프 퀘스트를 많이 진행하지 못하였는데, 미션 진행 중 알게 모르게 학습과 구현 비중을 많이 물어봤던 것 같습니다. 해당 퀘스트로 인해 미션 진행 중 적절한 학습과 구현의 비중을 나누어 수행했던 것 같습니다.
</details>

<details>
  <summary>J053_김영서</summary>

### 해당 퀘스트를 수행하는 데 AI는 어떤 역할이었나요? AI가 없으면 동일한 결과를 얻을 수 없을까요?

AI는 정보를 검색하는데 좋은 도구입니다. 문제에 대한 정보를 입력하면 관련된 지식을 자동으로 정리해서 알려주었습니다. AI가 없으면 검색을 통해 비슷한 결과를 도출할 수 있었겠지만 더 오랜 시간이 걸렸을것 같습니다. 그러나 직접 찾아보는 과정속에서 더 깊은 학습이 가능할것 같습니다.

### 해당 퀘스트는 커뮤니티 또는 학습과 성장에 도움이 되었나요?

하루만에 과제를 수행해야하는 챌린지 특성상 빠른 수행이 필수적이었고 이러한 특성에 맞아 떨어져 학습/성장에 도움이 되었다고 생각합니다.

### 해당 퀘스트는 일주일동안 수행하기에 난이도나 분량이 어땠나요?

매일 정보를 얻는 역할이었기 때문에 난이도는 쉬웠습니다. 분량은 많았지만 어짜피 공부해야될 내용이라 상관없었습니다.

### 해당 퀘스트를 수행하며 나에게는 어떤 변화가 있었나요?

여러 개념을 익힐 수 있어 개념적 접근에 있어 유리했습니다.
</details>

<details>
  <summary>J193_이수진</summary>
  
- AI가 추천해준 아이스브레이킹 주제를 활용해보았습니다.
- 가볍고 재미있는 대화를 통해 서로를 더 잘 이해하고, 딱딱한 분위기를 부드럽게 만들 수 있었습니다.

### 💻 개발자 취향 주제
#### 💬 주제
- “코드 짤 때 음악 듣는다 vs 무조건 조용해야 집중된다?”

#### 🗣️ 나눈 이야기
- 코딩할 때 음악을 들으면 오히려 집중이 안 되기 때문에 조용한 환경을 선호한다는 의견이 있었습니다.
- 반면, 음악을 크게 틀어놓고 집중력이 올라가는 경우도 있다는 의견도 나왔습니다.

### 😎 TMI 토크 주제
#### 💬 주제
- “내 컴퓨터 배경화면 지금 뭐임?”

#### 🗣️ 나눈 이야기
- 그냥 검은색 배경화면을 사용한다는 사람이 있었고,
- 바다 등 자연 풍경 이미지를 배경으로 쓰는 사람도 있었습니다.

### 🧩 깜짝 선택 게임 (다수결 or 토론 가능!)
#### 💬 주제
- “다크모드 없는 세상 vs 마우스 없는 세상?”

#### 🗣️ 나눈 이야기
- 다크모드가 없으면 눈이 너무 피로할 것 같아서 마우스 없는 세상을 선택하겠다는 의견이 있었고,
- 반대로 마우스가 없으면 너무 불편할 것 같아서 차라리 다크모드 없는 세상을 선택하겠다는 의견도 나왔습니다.
</details>

<details>
  <summary>S006_김예슬</summary>
</details>
